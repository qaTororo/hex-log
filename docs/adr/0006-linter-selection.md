# ADR-0006: リンター選定

## ステータス

承認

## コンテキスト

コードの静的解析とフォーマットを自動化するツールを選定する必要がある。CI/CDパイプラインの最初のステップ（品質ゲート）として、lint→type-checkの順で実行する設計（→ 要件定義書 セクション8）。

求める要件:
- TypeScript/JSX/CSSの静的解析
- コードフォーマットの自動化（Prettierの役割を含む）
- CI内での実行速度が速いこと（高速フェイル原則の最初のゲート）
- pre-commitフックでの実行も想定するため、開発中の体感速度も重要
- 設定のシンプルさ。プラグインの選定・管理コストが低いこと

なお、筆者は業務でESLint + Prettierを日常的に実行しているが、設定の構築経験はなく（開発エンジニアが整備した設定をそのまま利用）、ツールの選定・評価は本プロジェクトが初めてとなる。

## 検討した選択肢

### 1. ESLint + Prettier

JavaScriptエコシステムの事実上の標準的な組み合わせ。ESLintが静的解析、Prettierがフォーマット。

- **メリット:**
  - エコシステム最大。ルールやプラグインが豊富（eslint-plugin-react, eslint-plugin-import等）
  - ほぼ全てのエディタ・IDEがサポート。設定情報やトラブルシューティングが充実
  - チームで広く使われており、知識の汎用性が高い
  - TypeScript対応が成熟（@typescript-eslint）
- **デメリット:**
  - **2つのツールの設定管理が必要。** eslint.config.js（Flat Config）+ .prettierrc の2ファイル。ルールの競合回避にeslint-config-prettierが必要
  - **実行速度が遅い。** JavaScript実装のため、大規模プロジェクトではリント時間が長い。小規模でも体感で数秒かかる
  - **プラグイン選定コスト。** 用途に応じたプラグインを選定・バージョン管理する必要がある
  - ESLint v9でFlat Configに移行。設定ファイルの書き方が過去の情報と異なり、混乱しやすい

### 2. deno lint

Denoに内蔵されたリンター。Rust実装で高速。

- **メリット:**
  - 追加インストール不要（Denoの一部）
  - Rust実装で非常に高速
  - 設定不要で使い始められる
- **デメリット:**
  - ランタイムとしてBunを採用済み（→ ADR-0002）のため、リントのためだけにDenoをインストールするのは不整合
  - カスタマイズ性がESLint/Biomeに比べて限定的
  - フォーマッター（`deno fmt`）が別コマンド

### 3. Biome

Rust実装のリンター+フォーマッター統合ツール。ESLint + Prettierを1つのツールで置き換える。

- **メリット:**
  - **1ツールで完結。** リンター + フォーマッターが統合されており、設定ファイルは `biome.json` の1つだけ
  - **Rust実装で高速。** ESLintの10〜20倍速い（公式ベンチマーク）。pre-commitフックでもストレスなし
  - **ゼロコンフィグ。** デフォルト設定が合理的で、設定なしでも十分に使える
  - **ESLint/Prettier互換ルール。** 主要なESLintルールとPrettierのフォーマットルールを内蔵
  - **エディタサポート。** VS Code拡張が公式提供されている
  - **インポート整理。** `isort`（Python）相当のインポート自動整理が組み込み
- **デメリット:**
  - ESLintほどのプラグインエコシステムがない。特殊なルール（特定フレームワーク固有のベストプラクティス等）が未対応の場合がある
  - 比較的新しいプロジェクト（2023年〜）のため、ESLintほどの実績・安定性の保証がない
  - CSSリントは対応しているが、stylelint相当の網羅性はまだ発展途上
  - Hono固有のルール（middleware patterns等）は存在しない（ESLintにも存在しないが）

### 比較軸

| 観点 | ESLint + Prettier | deno lint | Biome |
|------|-------------------|-----------|-------|
| 実行速度 | 遅い（JS実装） | 速い（Rust） | 速い（Rust） |
| 設定ファイル数 | 2-3個 | 1個 | 1個 |
| ツール数 | 2個 + アダプター | 1個 | 1個 |
| プラグイン | 豊富 | 限定的 | 成長中 |
| フォーマッター | Prettier（別ツール） | deno fmt（別コマンド） | 統合済み |
| エディタ統合 | ◎ | ○ | ○ |
| ランタイム整合性 | ○ | △（Bun採用済み） | ○ |
| 学習コスト | 高（設定が複雑） | 低 | 低 |

## 決定

**Biomeを採用する。**

以下の観点を自分で比較検討した上での判断:

- **設定のシンプルさが決め手。** ESLint + Prettierは2ツール+アダプターの設定管理が必要だが、Biomeは `biome.json` 1ファイルで完結する。個人開発で設定管理にコストをかけたくない
- **プラグインの差は実質的に影響しない。** Hono/Bun固有のリントルールはESLintにも存在しないため、プラグインエコシステムの豊富さは本プロジェクトでは優位性にならない
- **Tailwindクラスソート非対応は許容する。** `prettier-plugin-tailwindcss` によるクラス自動ソートはDX的に便利だが、必須ではない。将来的にBiome対応またはエディタ拡張で対応する可能性もある
- **リンター設定の構築経験がないため、シンプルさを重視した。** 業務ではESLint + Prettierを実行しているが、設定の構築・管理は未経験。ゼロから始めるならBiomeの方が参入障壁が低い

## 結果

- `biome.json` 1ファイルでリンター + フォーマッターが完結する。設定管理コストが最小
- Rust実装の高速性により、pre-commitフックとCIの両方で快適に実行できる。高速フェイル原則の最初のゲートとして適切
- `bun add -D @biomejs/biome` でインストールし、package.jsonのscriptsに `"lint": "biome check ."` を追加する
- 将来的にBiomeでカバーできない特殊なルールが必要になった場合は、ESLintとの併用も検討する（Biomeは他ツールとの共存を妨げない）
