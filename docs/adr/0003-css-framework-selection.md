# ADR-0003: CSSフレームワーク選定

## ステータス

承認

## コンテキスト

ブログのスタイリング手法を選定する必要がある。要件は以下の通り。

- レスポンシブデザイン（320px〜1280px）を効率的に実装できること
- Viteとの統合が容易であること
- デザインシステムやUIライブラリへの依存を避け、自分でスタイリングを制御できること
- ダークモード対応（Shouldフェーズ）への拡張が可能であること

## 検討した選択肢

### 1. CSS Modules

コンポーネントスコープのCSSをビルド時に生成する手法。クラス名が自動でユニークになる。

- **メリット:**
  - 素のCSSを書くため、CSS自体の学習に直結する
  - スコープが自動で閉じるため、名前衝突の心配がない
  - Viteが標準サポート（`.module.css` で自動認識）。追加プラグイン不要
  - バンドルサイズが小さい（使用したスタイルのみ出力）
- **デメリット:**
  - レスポンシブやダークモードのユーティリティを自分で定義する必要がある
  - デザイントークン（色、間隔等）の一貫性を自分で管理する仕組みが必要
  - 同じようなスタイルパターンの繰り返し記述が多くなりがち

### 2. CSS-in-JS（styled-components / Emotion）

JavaScriptの中でCSSを記述する手法。動的スタイリングに強い。

- **メリット:**
  - コンポーネントとスタイルが同じファイルに共存。凝集度が高い
  - propsによる動的スタイリングが直感的
  - TypeScriptとの統合が良い（型付きのスタイルprops）
- **デメリット:**
  - ランタイムのオーバーヘッド（CSSをJSで生成するコスト）
  - SSG/SSR時のCSS抽出に追加設定が必要
  - Honoの軽量性と相反する（Reactへの依存を前提とするライブラリが多い）
  - フロントエンド戦略（→ ADR-0007）が未確定の現時点では、React依存のライブラリを採用するリスクが高い

### 3. Vanilla CSS（フレームワークなし）

素のCSSのみでスタイリングする。カスタムプロパティ（CSS変数）とnestingで構造化。

- **メリット:**
  - 外部依存ゼロ。最もシンプル
  - CSSの最新仕様（nesting, :has(), container queries等）を直接学べる
  - バンドルサイズへの影響なし
- **デメリット:**
  - デザイントークンの管理、レスポンシブのブレークポイント管理を全て自前で行う必要がある
  - 開発速度が遅い。ユーティリティクラスがないため、毎回セレクタを定義する
  - チーム開発時の一貫性を保つ仕組みがない（個人開発では問題にならないが、プラクティスとして）

### 4. Tailwind CSS v4

ユーティリティファーストのCSSフレームワーク。v4ではCSS-firstの設計に刷新され、`@import "tailwindcss"` だけで動作する。

- **メリット:**
  - **ゼロコンフィグ:** v4では `tailwind.config.js` が不要。CSSファイルの `@import "tailwindcss"` だけで起動する
  - **Vite統合:** `@tailwindcss/vite` プラグインにより、Viteとのネイティブ統合が実現
  - **高速な開発:** ユーティリティクラスによりHTMLとスタイルが同じ場所に共存。CSSファイルへのコンテキストスイッチが不要
  - **レスポンシブ:** `sm:`, `md:`, `lg:` プレフィックスで宣言的にブレークポイント指定
  - **ダークモード:** `dark:` プレフィックスで宣言的に対応。Shouldフェーズへの拡張が容易
  - **デザイン一貫性:** 組み込みのデザイントークン（色、間隔、フォントサイズ等）により、自然と一貫したデザインになる
  - **未使用CSSの自動除去:** ビルド時に使用されていないユーティリティを除去。バンドルサイズが小さい
- **デメリット:**
  - HTMLのclass属性が長くなり、可読性が下がる場合がある
  - CSS自体の深い学習にはならない。ただし、ユーティリティクラス名がCSS propertyの短縮形であるため、逆引き的にCSSの基礎概念（Flexbox、Grid、spacing、responsive breakpoints等）に触れることはできる
  - v4は2024年リリースで、v3からの移行情報は多いがv4ネイティブの情報はまだ発展途上

### 比較軸

| 観点 | CSS Modules | CSS-in-JS | Vanilla CSS | Tailwind v4 |
|------|-------------|-----------|-------------|-------------|
| 開発速度 | 中 | 中 | 低 | 高 |
| Vite統合 | ○ 標準 | △ 要設定 | ○ 不要 | ○ プラグイン |
| レスポンシブ | 自前 | 自前 | 自前 | 組み込み |
| ダークモード拡張 | 自前 | propsで容易 | 自前 | 組み込み |
| バンドルサイズ | 小 | 中（ランタイム） | 最小 | 小（PurgeCSS） |
| React依存 | なし | 多くは必要 | なし | なし |
| CSS学習価値 | 高 | 低 | 最高 | 低 |

## 決定

**Tailwind CSS v4を採用する。**

## 結果

- v4のゼロコンフィグにより、`@import "tailwindcss"` と `@tailwindcss/vite` プラグインだけで動作する。設定ファイルのメンテナンスが不要
- ユーティリティクラスによる高速な開発サイクル。週1本以上の更新頻度を支えるDXを確保
- レスポンシブ・ダークモードが宣言的に記述可能。Shouldフェーズの機能拡張が容易
- フロントエンド戦略（→ ADR-0007）に依存しない選択。Hono JSXでもReactでも同じように使える
- CSSの深い学習は本プロジェクトの主目的ではない。ただし、Tailwindのユーティリティクラスを日常的に使うことで「CSSの基礎を理解している」と言えるレベルには到達できると判断した。CSSを一から書くスキルの習得は目的外とする
